<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.2" />
<title>pacman.gamestate API documentation</title>
<meta name="description" content="This file describes the Pacman game state model and game logic." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pacman.gamestate</code></h1>
</header>
<section id="section-intro">
<p>This file describes the Pacman game state model and game logic.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This file describes the Pacman game state model and game logic.
&#34;&#34;&#34;

from typing import List

from . import array, layouts, util


class Gamestate:
    PACMAN_ID = 0
    &#34;&#34;&#34;the index of the pacman agent&#34;&#34;&#34;
    SCARED_TIME = 40
    &#34;&#34;&#34;amount of moves that ghosts are scared when Pacman eats a pellet&#34;&#34;&#34;
    SCORE_GET_DOT = 10
    &#34;&#34;&#34;score for getting a dot&#34;&#34;&#34;
    SCORE_GET_ALL_DOTS = 500
    &#34;&#34;&#34;score for getting all dots&#34;&#34;&#34;
    SCORE_GET_PELLET = 5
    &#34;&#34;&#34;score for getting a pellet&#34;&#34;&#34;
    SCORE_GET_GHOST = 200
    &#34;&#34;&#34;score for eating a ghost while it&#39;s vulnerable&#34;&#34;&#34;
    SCORE_TICK_PENALTY = -1
    &#34;&#34;&#34;penalty applied for each turn of the game&#34;&#34;&#34;
    SCORE_DIE_PENALTY = -500
    &#34;&#34;&#34;negative score for dying&#34;&#34;&#34;
    MAX_TICKS = 3000
    &#34;&#34;&#34;maximum amount of turns before Pacman dies automatically&#34;&#34;&#34;

    def __init__(self, arr: array.Array, agents: List[util.Vector] = None) -&gt; None:
        &#34;&#34;&#34;
        The gamestate handles the logic of the game, it will be used a lot during the assignments.

        :param arr: the initial layout
        :param agents: the initial locations of all agents. Pacman is agent 0
        &#34;&#34;&#34;
        self._statics = arr.copy()
        # agents contains the current locations of all agents
        if agents:
            self.agents = agents.copy()
        else:
            self.agents = arr.list(layouts.LayoutObject.pacman) + arr.list(layouts.LayoutObject.ghost)
        for x, y in self.active_agents:  # clear floor beneath agents
            self._statics[x, y] = layouts.LayoutObject.empty
        self.starts = self.agents.copy()  # remember start locations
        self.facings = [util.Move.stop] * len(self.agents)  # the way that each agent is facing
        self._timers = [0] * len(self.agents)  # all agents&#39; scared timers (Pacman&#39;s is not used)
        self.score = 0  # current score
        self._tick = 0  # current turn

    @property
    def pacman(self) -&gt; util.Vector:
        &#34;&#34;&#34;
        Pacman&#39;s current location
        &#34;&#34;&#34;
        return self.agents[self.PACMAN_ID]

    @property
    def ghosts(self) -&gt; List[util.Vector]:
        &#34;&#34;&#34;
        Current locations of all ghosts
        &#34;&#34;&#34;
        return self.agents[self.PACMAN_ID + 1:]

    @property
    def timers(self) -&gt; List[int]:
        &#34;&#34;&#34;
        Current scared timers of all ghosts
        &#34;&#34;&#34;
        return self._timers[1:]

    @property
    def active_agents(self) -&gt; List[util.Vector]:
        &#34;&#34;&#34;
        Locations of agents that are currently alive
        &#34;&#34;&#34;
        return [agent for agent in self.agents if agent]

    @property
    def walls(self) -&gt; array.IndicatorArray:
        &#34;&#34;&#34;
        Array indicating layout of walls
        &#34;&#34;&#34;
        return self._statics.indicate(layouts.LayoutObject.wall)

    @property
    def dots(self) -&gt; array.IndicatorArray:
        &#34;&#34;&#34;
        Array indicating layout of dots
        &#34;&#34;&#34;
        return self._statics.indicate(layouts.LayoutObject.dot)

    @property
    def pellets(self) -&gt; array.IndicatorArray:
        &#34;&#34;&#34;
        Array indicating layout of pellets
        &#34;&#34;&#34;
        return self._statics.indicate(layouts.LayoutObject.pellet)

    @property
    def shape(self) -&gt; util.Vector:
        &#34;&#34;&#34;
        Tuple indicating the shape of the layout
        &#34;&#34;&#34;
        return self._statics.shape

    @property
    def copy(self):
        &#34;&#34;&#34;
        Create an independent copy of the gamestate
        &#34;&#34;&#34;
        copy = Gamestate(array.Array([]))
        copy._statics = self._statics.copy()
        copy.agents = self.agents.copy()
        copy.starts = self.starts.copy()
        copy.facings = self.facings.copy()
        copy._timers = self._timers.copy()
        copy.score = self.score
        copy._tick = self._tick
        return copy

    def apply_move(self, agent_id: int, move: util.Move):
        &#34;&#34;&#34;
        Logic for applying an agent&#39;s move to the gamestate. Gamestate is modified in-place.
        :param agent_id: the ID of the agent
        :param move: the agent&#39;s move
        :return:
        &#34;&#34;&#34;
        if not self.agents[agent_id]:  # agent is dead
            return

        if not move:  # agent made no move or was not allowed to move (current move executing)
            move = util.Move.stop

        self.facings[agent_id] = move  # update agent&#39;s facing

        vector = self.agents[agent_id]  # get agent&#39;s current location
        new_vector = vector + move.vector  # calculate new location
        self.agents[agent_id] = new_vector  # set new location

        if self._timers[agent_id]:  # if agent is currently scared, reduce their timer
            self._timers[agent_id] -= 1

        if agent_id == self.PACMAN_ID:  # if agent is Pacman, apply turn penalty
            self.score += self.SCORE_TICK_PENALTY

        if self.walls[new_vector]:  # if agent moves into a wall, end the game
            if agent_id == self.PACMAN_ID:
                self.score += self.SCORE_DIE_PENALTY
            raise RuntimeError(f&#39;agent {agent_id} walked into a wall at {new_vector}&#39;)

        if agent_id == self.PACMAN_ID:

            if new_vector in self.ghosts:  # if Pacman runs into a ghost, resolve the encounter
                ghost_id = self.ghosts.index(new_vector) + 1
                self._resolve_encounter(ghost_id)

            if self.dots[new_vector]:  # if Pacman runs into a dot, eat it and reward score
                self._statics[new_vector] = layouts.LayoutObject.empty
                self.score += self.SCORE_GET_DOT
                if not self.dots.list():
                    self.score += self.SCORE_GET_ALL_DOTS

            if self.pellets[new_vector]:  # if Pacman runs into a pellet, eat it, reward score, and set timers
                self._statics[new_vector] = layouts.LayoutObject.empty
                self.score += self.SCORE_GET_PELLET
                self._timers[1:] = [self.SCARED_TIME] * len(self._timers[1:])

        else:

            if new_vector == self.pacman:  # if a ghost runs into Pacman, resolve the encounter
                self._resolve_encounter(agent_id)

    def _resolve_encounter(self, ghost_id: int):
        &#34;&#34;&#34;
        Resolve an encounter between Pacman and a ghost
        :param ghost_id:
        &#34;&#34;&#34;
        if self._timers[ghost_id]:  # pacman kills the ghost
            self.kill(ghost_id)
            self.score += self.SCORE_GET_GHOST
        else:  # the ghost kills pacman
            self.kill(self.PACMAN_ID)
            self.score += self.SCORE_DIE_PENALTY

    def can_move(self, agent_id: int):
        &#34;&#34;&#34;
        Check whether a certain agent is allowed to move.
        To be allowed to move, an agent needs to be alive and if it is scared,
        the current turn number must be even. This makes scared ghosts move
        twice as slowly as regular agents.
        &#34;&#34;&#34;
        return self.agents[agent_id] and (not self._timers[agent_id] or self._tick % 2 == 0) and not self.gameover

    def legal_moves_vector(self, vector: util.Vector):
        &#34;&#34;&#34;
        Get all moves that are possible from a particular location (taking walls into consideration).
        &#34;&#34;&#34;
        moves = set()
        for move in util.Move:
            new_vector = vector + move.vector
            if not self.walls[new_vector]:
                moves.add(move)
        return moves

    def legal_moves_id(self, agent_id: int):
        &#34;&#34;&#34;
        Get all moves from a particular agent&#39;s current location (taking walls into consideration).
        &#34;&#34;&#34;
        return self.legal_moves_vector(self.agents[agent_id])

    @property
    def win(self) -&gt; bool:
        &#34;&#34;&#34;
        Whether Pacman has won the game. This is the case when all dots have been eaten.
        &#34;&#34;&#34;
        return not self.loss and not self.dots.list()

    @property
    def loss(self) -&gt; bool:
        &#34;&#34;&#34;
        Whether Pacman has lost the game. This is the case when Pacman is dead.
        &#34;&#34;&#34;
        return not self.pacman

    @property
    def gameover(self) -&gt; bool:
        &#34;&#34;&#34;
        Whether the game is over. This is the case when Pacman has won or lost the game.
        &#34;&#34;&#34;
        return self.win or self.loss

    def tick(self):
        &#34;&#34;&#34;
        Increase the game&#39;s turn number.
        &#34;&#34;&#34;
        self._tick += 1

        if self._tick == self.MAX_TICKS:
            self.destroy(self.PACMAN_ID)
            print(f&#39;WARNING: max number of ticks reached ({self.MAX_TICKS}) pacman was destroyed&#39;)

    def kill(self, agent_id: int):
        &#34;&#34;&#34;
        Kill a certain agent. In the case of ghosts, this resets them to their starting location.
        The Gamestate calls this when there&#39;s an encounter between pacman and a ghost.
        &#34;&#34;&#34;
        if agent_id == self.PACMAN_ID:
            self.agents[agent_id] = None
        else:
            self.agents[agent_id] = self.starts[agent_id]
            self._timers[agent_id] = 0

    def destroy(self, agent_id: int):
        &#34;&#34;&#34;
        Destroy a certain agent. Contrary to `kill`, ghosts do not reset with `destroy`.
        &#34;&#34;&#34;
        self.agents[agent_id] = None
        if agent_id == 0:  # Pacman forcefully destroyed as penalty (max ticks / timeout); subtract score
            self.score += self.SCORE_DIE_PENALTY

    def successor(self, agent_id: int, move: util.Move):
        &#34;&#34;&#34;
        Get a new gamestate based on this one, where the given agent has executed the given move.
        &#34;&#34;&#34;
        successor = self.copy
        successor.apply_move(agent_id, move)
        return successor

    def successors(self, agent_id: int):
        &#34;&#34;&#34;
        Get all possible gamestates following this one, in which the given agent had executed a single move.
        &#34;&#34;&#34;
        return [self.successor(agent_id, move) for move in self.legal_moves_vector(self.agents[agent_id])]

    def __repr__(self):
        &#34;&#34;&#34;
        Official string representation.
        &#34;&#34;&#34;
        data = str({&#39;agents&#39;: self.agents,
                    &#39;facings&#39;: self.facings,
                    &#39;timers&#39;: self.timers,
                    &#39;dots&#39;: self.dots.list(),
                    &#39;pellets&#39;: self.pellets.list(),
                    &#39;score&#39;: self.score,
                    &#39;tick&#39;: self._tick})
        return f&#39;Gamestate({data})&#39;

    def __str__(self):
        &#34;&#34;&#34;
        Informal string representation.
        &#34;&#34;&#34;
        layout = self._statics.copy()
        if self.pacman:
            layout[self.pacman] = layouts.LayoutObject.pacman
        for ghost, timer in zip(self.ghosts, self.timers):
            if ghost:
                if timer:
                    layout[ghost] = layouts.LayoutObject.ghost_scared
                else:
                    layout[ghost] = layouts.LayoutObject.ghost
        return str(layout.transpose.mirror_hor) + f&#39;\nScore: {self.score}&#39;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pacman.gamestate.Gamestate"><code class="flex name class">
<span>class <span class="ident">Gamestate</span></span>
<span>(</span><span>arr, agents=None)</span>
</code></dt>
<dd>
<section class="desc"><p>The gamestate handles the logic of the game, it will be used a lot during the assignments.</p>
<p>:param arr: the initial layout
:param agents: the initial locations of all agents. Pacman is agent 0</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Gamestate:
    PACMAN_ID = 0
    &#34;&#34;&#34;the index of the pacman agent&#34;&#34;&#34;
    SCARED_TIME = 40
    &#34;&#34;&#34;amount of moves that ghosts are scared when Pacman eats a pellet&#34;&#34;&#34;
    SCORE_GET_DOT = 10
    &#34;&#34;&#34;score for getting a dot&#34;&#34;&#34;
    SCORE_GET_ALL_DOTS = 500
    &#34;&#34;&#34;score for getting all dots&#34;&#34;&#34;
    SCORE_GET_PELLET = 5
    &#34;&#34;&#34;score for getting a pellet&#34;&#34;&#34;
    SCORE_GET_GHOST = 200
    &#34;&#34;&#34;score for eating a ghost while it&#39;s vulnerable&#34;&#34;&#34;
    SCORE_TICK_PENALTY = -1
    &#34;&#34;&#34;penalty applied for each turn of the game&#34;&#34;&#34;
    SCORE_DIE_PENALTY = -500
    &#34;&#34;&#34;negative score for dying&#34;&#34;&#34;
    MAX_TICKS = 3000
    &#34;&#34;&#34;maximum amount of turns before Pacman dies automatically&#34;&#34;&#34;

    def __init__(self, arr: array.Array, agents: List[util.Vector] = None) -&gt; None:
        &#34;&#34;&#34;
        The gamestate handles the logic of the game, it will be used a lot during the assignments.

        :param arr: the initial layout
        :param agents: the initial locations of all agents. Pacman is agent 0
        &#34;&#34;&#34;
        self._statics = arr.copy()
        # agents contains the current locations of all agents
        if agents:
            self.agents = agents.copy()
        else:
            self.agents = arr.list(layouts.LayoutObject.pacman) + arr.list(layouts.LayoutObject.ghost)
        for x, y in self.active_agents:  # clear floor beneath agents
            self._statics[x, y] = layouts.LayoutObject.empty
        self.starts = self.agents.copy()  # remember start locations
        self.facings = [util.Move.stop] * len(self.agents)  # the way that each agent is facing
        self._timers = [0] * len(self.agents)  # all agents&#39; scared timers (Pacman&#39;s is not used)
        self.score = 0  # current score
        self._tick = 0  # current turn

    @property
    def pacman(self) -&gt; util.Vector:
        &#34;&#34;&#34;
        Pacman&#39;s current location
        &#34;&#34;&#34;
        return self.agents[self.PACMAN_ID]

    @property
    def ghosts(self) -&gt; List[util.Vector]:
        &#34;&#34;&#34;
        Current locations of all ghosts
        &#34;&#34;&#34;
        return self.agents[self.PACMAN_ID + 1:]

    @property
    def timers(self) -&gt; List[int]:
        &#34;&#34;&#34;
        Current scared timers of all ghosts
        &#34;&#34;&#34;
        return self._timers[1:]

    @property
    def active_agents(self) -&gt; List[util.Vector]:
        &#34;&#34;&#34;
        Locations of agents that are currently alive
        &#34;&#34;&#34;
        return [agent for agent in self.agents if agent]

    @property
    def walls(self) -&gt; array.IndicatorArray:
        &#34;&#34;&#34;
        Array indicating layout of walls
        &#34;&#34;&#34;
        return self._statics.indicate(layouts.LayoutObject.wall)

    @property
    def dots(self) -&gt; array.IndicatorArray:
        &#34;&#34;&#34;
        Array indicating layout of dots
        &#34;&#34;&#34;
        return self._statics.indicate(layouts.LayoutObject.dot)

    @property
    def pellets(self) -&gt; array.IndicatorArray:
        &#34;&#34;&#34;
        Array indicating layout of pellets
        &#34;&#34;&#34;
        return self._statics.indicate(layouts.LayoutObject.pellet)

    @property
    def shape(self) -&gt; util.Vector:
        &#34;&#34;&#34;
        Tuple indicating the shape of the layout
        &#34;&#34;&#34;
        return self._statics.shape

    @property
    def copy(self):
        &#34;&#34;&#34;
        Create an independent copy of the gamestate
        &#34;&#34;&#34;
        copy = Gamestate(array.Array([]))
        copy._statics = self._statics.copy()
        copy.agents = self.agents.copy()
        copy.starts = self.starts.copy()
        copy.facings = self.facings.copy()
        copy._timers = self._timers.copy()
        copy.score = self.score
        copy._tick = self._tick
        return copy

    def apply_move(self, agent_id: int, move: util.Move):
        &#34;&#34;&#34;
        Logic for applying an agent&#39;s move to the gamestate. Gamestate is modified in-place.
        :param agent_id: the ID of the agent
        :param move: the agent&#39;s move
        :return:
        &#34;&#34;&#34;
        if not self.agents[agent_id]:  # agent is dead
            return

        if not move:  # agent made no move or was not allowed to move (current move executing)
            move = util.Move.stop

        self.facings[agent_id] = move  # update agent&#39;s facing

        vector = self.agents[agent_id]  # get agent&#39;s current location
        new_vector = vector + move.vector  # calculate new location
        self.agents[agent_id] = new_vector  # set new location

        if self._timers[agent_id]:  # if agent is currently scared, reduce their timer
            self._timers[agent_id] -= 1

        if agent_id == self.PACMAN_ID:  # if agent is Pacman, apply turn penalty
            self.score += self.SCORE_TICK_PENALTY

        if self.walls[new_vector]:  # if agent moves into a wall, end the game
            if agent_id == self.PACMAN_ID:
                self.score += self.SCORE_DIE_PENALTY
            raise RuntimeError(f&#39;agent {agent_id} walked into a wall at {new_vector}&#39;)

        if agent_id == self.PACMAN_ID:

            if new_vector in self.ghosts:  # if Pacman runs into a ghost, resolve the encounter
                ghost_id = self.ghosts.index(new_vector) + 1
                self._resolve_encounter(ghost_id)

            if self.dots[new_vector]:  # if Pacman runs into a dot, eat it and reward score
                self._statics[new_vector] = layouts.LayoutObject.empty
                self.score += self.SCORE_GET_DOT
                if not self.dots.list():
                    self.score += self.SCORE_GET_ALL_DOTS

            if self.pellets[new_vector]:  # if Pacman runs into a pellet, eat it, reward score, and set timers
                self._statics[new_vector] = layouts.LayoutObject.empty
                self.score += self.SCORE_GET_PELLET
                self._timers[1:] = [self.SCARED_TIME] * len(self._timers[1:])

        else:

            if new_vector == self.pacman:  # if a ghost runs into Pacman, resolve the encounter
                self._resolve_encounter(agent_id)

    def _resolve_encounter(self, ghost_id: int):
        &#34;&#34;&#34;
        Resolve an encounter between Pacman and a ghost
        :param ghost_id:
        &#34;&#34;&#34;
        if self._timers[ghost_id]:  # pacman kills the ghost
            self.kill(ghost_id)
            self.score += self.SCORE_GET_GHOST
        else:  # the ghost kills pacman
            self.kill(self.PACMAN_ID)
            self.score += self.SCORE_DIE_PENALTY

    def can_move(self, agent_id: int):
        &#34;&#34;&#34;
        Check whether a certain agent is allowed to move.
        To be allowed to move, an agent needs to be alive and if it is scared,
        the current turn number must be even. This makes scared ghosts move
        twice as slowly as regular agents.
        &#34;&#34;&#34;
        return self.agents[agent_id] and (not self._timers[agent_id] or self._tick % 2 == 0) and not self.gameover

    def legal_moves_vector(self, vector: util.Vector):
        &#34;&#34;&#34;
        Get all moves that are possible from a particular location (taking walls into consideration).
        &#34;&#34;&#34;
        moves = set()
        for move in util.Move:
            new_vector = vector + move.vector
            if not self.walls[new_vector]:
                moves.add(move)
        return moves

    def legal_moves_id(self, agent_id: int):
        &#34;&#34;&#34;
        Get all moves from a particular agent&#39;s current location (taking walls into consideration).
        &#34;&#34;&#34;
        return self.legal_moves_vector(self.agents[agent_id])

    @property
    def win(self) -&gt; bool:
        &#34;&#34;&#34;
        Whether Pacman has won the game. This is the case when all dots have been eaten.
        &#34;&#34;&#34;
        return not self.loss and not self.dots.list()

    @property
    def loss(self) -&gt; bool:
        &#34;&#34;&#34;
        Whether Pacman has lost the game. This is the case when Pacman is dead.
        &#34;&#34;&#34;
        return not self.pacman

    @property
    def gameover(self) -&gt; bool:
        &#34;&#34;&#34;
        Whether the game is over. This is the case when Pacman has won or lost the game.
        &#34;&#34;&#34;
        return self.win or self.loss

    def tick(self):
        &#34;&#34;&#34;
        Increase the game&#39;s turn number.
        &#34;&#34;&#34;
        self._tick += 1

        if self._tick == self.MAX_TICKS:
            self.destroy(self.PACMAN_ID)
            print(f&#39;WARNING: max number of ticks reached ({self.MAX_TICKS}) pacman was destroyed&#39;)

    def kill(self, agent_id: int):
        &#34;&#34;&#34;
        Kill a certain agent. In the case of ghosts, this resets them to their starting location.
        The Gamestate calls this when there&#39;s an encounter between pacman and a ghost.
        &#34;&#34;&#34;
        if agent_id == self.PACMAN_ID:
            self.agents[agent_id] = None
        else:
            self.agents[agent_id] = self.starts[agent_id]
            self._timers[agent_id] = 0

    def destroy(self, agent_id: int):
        &#34;&#34;&#34;
        Destroy a certain agent. Contrary to `kill`, ghosts do not reset with `destroy`.
        &#34;&#34;&#34;
        self.agents[agent_id] = None
        if agent_id == 0:  # Pacman forcefully destroyed as penalty (max ticks / timeout); subtract score
            self.score += self.SCORE_DIE_PENALTY

    def successor(self, agent_id: int, move: util.Move):
        &#34;&#34;&#34;
        Get a new gamestate based on this one, where the given agent has executed the given move.
        &#34;&#34;&#34;
        successor = self.copy
        successor.apply_move(agent_id, move)
        return successor

    def successors(self, agent_id: int):
        &#34;&#34;&#34;
        Get all possible gamestates following this one, in which the given agent had executed a single move.
        &#34;&#34;&#34;
        return [self.successor(agent_id, move) for move in self.legal_moves_vector(self.agents[agent_id])]

    def __repr__(self):
        &#34;&#34;&#34;
        Official string representation.
        &#34;&#34;&#34;
        data = str({&#39;agents&#39;: self.agents,
                    &#39;facings&#39;: self.facings,
                    &#39;timers&#39;: self.timers,
                    &#39;dots&#39;: self.dots.list(),
                    &#39;pellets&#39;: self.pellets.list(),
                    &#39;score&#39;: self.score,
                    &#39;tick&#39;: self._tick})
        return f&#39;Gamestate({data})&#39;

    def __str__(self):
        &#34;&#34;&#34;
        Informal string representation.
        &#34;&#34;&#34;
        layout = self._statics.copy()
        if self.pacman:
            layout[self.pacman] = layouts.LayoutObject.pacman
        for ghost, timer in zip(self.ghosts, self.timers):
            if ghost:
                if timer:
                    layout[ghost] = layouts.LayoutObject.ghost_scared
                else:
                    layout[ghost] = layouts.LayoutObject.ghost
        return str(layout.transpose.mirror_hor) + f&#39;\nScore: {self.score}&#39;</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="pacman.gamestate.Gamestate.MAX_TICKS"><code class="name">var <span class="ident">MAX_TICKS</span></code></dt>
<dd>
<section class="desc"><p>maximum amount of turns before Pacman dies automatically</p></section>
</dd>
<dt id="pacman.gamestate.Gamestate.PACMAN_ID"><code class="name">var <span class="ident">PACMAN_ID</span></code></dt>
<dd>
<section class="desc"><p>the index of the pacman agent</p></section>
</dd>
<dt id="pacman.gamestate.Gamestate.SCARED_TIME"><code class="name">var <span class="ident">SCARED_TIME</span></code></dt>
<dd>
<section class="desc"><p>amount of moves that ghosts are scared when Pacman eats a pellet</p></section>
</dd>
<dt id="pacman.gamestate.Gamestate.SCORE_DIE_PENALTY"><code class="name">var <span class="ident">SCORE_DIE_PENALTY</span></code></dt>
<dd>
<section class="desc"><p>negative score for dying</p></section>
</dd>
<dt id="pacman.gamestate.Gamestate.SCORE_GET_ALL_DOTS"><code class="name">var <span class="ident">SCORE_GET_ALL_DOTS</span></code></dt>
<dd>
<section class="desc"><p>score for getting all dots</p></section>
</dd>
<dt id="pacman.gamestate.Gamestate.SCORE_GET_DOT"><code class="name">var <span class="ident">SCORE_GET_DOT</span></code></dt>
<dd>
<section class="desc"><p>score for getting a dot</p></section>
</dd>
<dt id="pacman.gamestate.Gamestate.SCORE_GET_GHOST"><code class="name">var <span class="ident">SCORE_GET_GHOST</span></code></dt>
<dd>
<section class="desc"><p>score for eating a ghost while it's vulnerable</p></section>
</dd>
<dt id="pacman.gamestate.Gamestate.SCORE_GET_PELLET"><code class="name">var <span class="ident">SCORE_GET_PELLET</span></code></dt>
<dd>
<section class="desc"><p>score for getting a pellet</p></section>
</dd>
<dt id="pacman.gamestate.Gamestate.SCORE_TICK_PENALTY"><code class="name">var <span class="ident">SCORE_TICK_PENALTY</span></code></dt>
<dd>
<section class="desc"><p>penalty applied for each turn of the game</p></section>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="pacman.gamestate.Gamestate.active_agents"><code class="name">var <span class="ident">active_agents</span></code></dt>
<dd>
<section class="desc"><p>Locations of agents that are currently alive</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def active_agents(self) -&gt; List[util.Vector]:
    &#34;&#34;&#34;
    Locations of agents that are currently alive
    &#34;&#34;&#34;
    return [agent for agent in self.agents if agent]</code></pre>
</details>
</dd>
<dt id="pacman.gamestate.Gamestate.copy"><code class="name">var <span class="ident">copy</span></code></dt>
<dd>
<section class="desc"><p>Create an independent copy of the gamestate</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def copy(self):
    &#34;&#34;&#34;
    Create an independent copy of the gamestate
    &#34;&#34;&#34;
    copy = Gamestate(array.Array([]))
    copy._statics = self._statics.copy()
    copy.agents = self.agents.copy()
    copy.starts = self.starts.copy()
    copy.facings = self.facings.copy()
    copy._timers = self._timers.copy()
    copy.score = self.score
    copy._tick = self._tick
    return copy</code></pre>
</details>
</dd>
<dt id="pacman.gamestate.Gamestate.dots"><code class="name">var <span class="ident">dots</span></code></dt>
<dd>
<section class="desc"><p>Array indicating layout of dots</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dots(self) -&gt; array.IndicatorArray:
    &#34;&#34;&#34;
    Array indicating layout of dots
    &#34;&#34;&#34;
    return self._statics.indicate(layouts.LayoutObject.dot)</code></pre>
</details>
</dd>
<dt id="pacman.gamestate.Gamestate.gameover"><code class="name">var <span class="ident">gameover</span></code></dt>
<dd>
<section class="desc"><p>Whether the game is over. This is the case when Pacman has won or lost the game.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def gameover(self) -&gt; bool:
    &#34;&#34;&#34;
    Whether the game is over. This is the case when Pacman has won or lost the game.
    &#34;&#34;&#34;
    return self.win or self.loss</code></pre>
</details>
</dd>
<dt id="pacman.gamestate.Gamestate.ghosts"><code class="name">var <span class="ident">ghosts</span></code></dt>
<dd>
<section class="desc"><p>Current locations of all ghosts</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ghosts(self) -&gt; List[util.Vector]:
    &#34;&#34;&#34;
    Current locations of all ghosts
    &#34;&#34;&#34;
    return self.agents[self.PACMAN_ID + 1:]</code></pre>
</details>
</dd>
<dt id="pacman.gamestate.Gamestate.loss"><code class="name">var <span class="ident">loss</span></code></dt>
<dd>
<section class="desc"><p>Whether Pacman has lost the game. This is the case when Pacman is dead.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def loss(self) -&gt; bool:
    &#34;&#34;&#34;
    Whether Pacman has lost the game. This is the case when Pacman is dead.
    &#34;&#34;&#34;
    return not self.pacman</code></pre>
</details>
</dd>
<dt id="pacman.gamestate.Gamestate.pacman"><code class="name">var <span class="ident">pacman</span></code></dt>
<dd>
<section class="desc"><p>Pacman's current location</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def pacman(self) -&gt; util.Vector:
    &#34;&#34;&#34;
    Pacman&#39;s current location
    &#34;&#34;&#34;
    return self.agents[self.PACMAN_ID]</code></pre>
</details>
</dd>
<dt id="pacman.gamestate.Gamestate.pellets"><code class="name">var <span class="ident">pellets</span></code></dt>
<dd>
<section class="desc"><p>Array indicating layout of pellets</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def pellets(self) -&gt; array.IndicatorArray:
    &#34;&#34;&#34;
    Array indicating layout of pellets
    &#34;&#34;&#34;
    return self._statics.indicate(layouts.LayoutObject.pellet)</code></pre>
</details>
</dd>
<dt id="pacman.gamestate.Gamestate.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<section class="desc"><p>Tuple indicating the shape of the layout</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self) -&gt; util.Vector:
    &#34;&#34;&#34;
    Tuple indicating the shape of the layout
    &#34;&#34;&#34;
    return self._statics.shape</code></pre>
</details>
</dd>
<dt id="pacman.gamestate.Gamestate.timers"><code class="name">var <span class="ident">timers</span></code></dt>
<dd>
<section class="desc"><p>Current scared timers of all ghosts</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def timers(self) -&gt; List[int]:
    &#34;&#34;&#34;
    Current scared timers of all ghosts
    &#34;&#34;&#34;
    return self._timers[1:]</code></pre>
</details>
</dd>
<dt id="pacman.gamestate.Gamestate.walls"><code class="name">var <span class="ident">walls</span></code></dt>
<dd>
<section class="desc"><p>Array indicating layout of walls</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def walls(self) -&gt; array.IndicatorArray:
    &#34;&#34;&#34;
    Array indicating layout of walls
    &#34;&#34;&#34;
    return self._statics.indicate(layouts.LayoutObject.wall)</code></pre>
</details>
</dd>
<dt id="pacman.gamestate.Gamestate.win"><code class="name">var <span class="ident">win</span></code></dt>
<dd>
<section class="desc"><p>Whether Pacman has won the game. This is the case when all dots have been eaten.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def win(self) -&gt; bool:
    &#34;&#34;&#34;
    Whether Pacman has won the game. This is the case when all dots have been eaten.
    &#34;&#34;&#34;
    return not self.loss and not self.dots.list()</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pacman.gamestate.Gamestate.apply_move"><code class="name flex">
<span>def <span class="ident">apply_move</span></span>(<span>self, agent_id, move)</span>
</code></dt>
<dd>
<section class="desc"><p>Logic for applying an agent's move to the gamestate. Gamestate is modified in-place.
:param agent_id: the ID of the agent
:param move: the agent's move
:return:</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_move(self, agent_id: int, move: util.Move):
    &#34;&#34;&#34;
    Logic for applying an agent&#39;s move to the gamestate. Gamestate is modified in-place.
    :param agent_id: the ID of the agent
    :param move: the agent&#39;s move
    :return:
    &#34;&#34;&#34;
    if not self.agents[agent_id]:  # agent is dead
        return

    if not move:  # agent made no move or was not allowed to move (current move executing)
        move = util.Move.stop

    self.facings[agent_id] = move  # update agent&#39;s facing

    vector = self.agents[agent_id]  # get agent&#39;s current location
    new_vector = vector + move.vector  # calculate new location
    self.agents[agent_id] = new_vector  # set new location

    if self._timers[agent_id]:  # if agent is currently scared, reduce their timer
        self._timers[agent_id] -= 1

    if agent_id == self.PACMAN_ID:  # if agent is Pacman, apply turn penalty
        self.score += self.SCORE_TICK_PENALTY

    if self.walls[new_vector]:  # if agent moves into a wall, end the game
        if agent_id == self.PACMAN_ID:
            self.score += self.SCORE_DIE_PENALTY
        raise RuntimeError(f&#39;agent {agent_id} walked into a wall at {new_vector}&#39;)

    if agent_id == self.PACMAN_ID:

        if new_vector in self.ghosts:  # if Pacman runs into a ghost, resolve the encounter
            ghost_id = self.ghosts.index(new_vector) + 1
            self._resolve_encounter(ghost_id)

        if self.dots[new_vector]:  # if Pacman runs into a dot, eat it and reward score
            self._statics[new_vector] = layouts.LayoutObject.empty
            self.score += self.SCORE_GET_DOT
            if not self.dots.list():
                self.score += self.SCORE_GET_ALL_DOTS

        if self.pellets[new_vector]:  # if Pacman runs into a pellet, eat it, reward score, and set timers
            self._statics[new_vector] = layouts.LayoutObject.empty
            self.score += self.SCORE_GET_PELLET
            self._timers[1:] = [self.SCARED_TIME] * len(self._timers[1:])

    else:

        if new_vector == self.pacman:  # if a ghost runs into Pacman, resolve the encounter
            self._resolve_encounter(agent_id)</code></pre>
</details>
</dd>
<dt id="pacman.gamestate.Gamestate.can_move"><code class="name flex">
<span>def <span class="ident">can_move</span></span>(<span>self, agent_id)</span>
</code></dt>
<dd>
<section class="desc"><p>Check whether a certain agent is allowed to move.
To be allowed to move, an agent needs to be alive and if it is scared,
the current turn number must be even. This makes scared ghosts move
twice as slowly as regular agents.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def can_move(self, agent_id: int):
    &#34;&#34;&#34;
    Check whether a certain agent is allowed to move.
    To be allowed to move, an agent needs to be alive and if it is scared,
    the current turn number must be even. This makes scared ghosts move
    twice as slowly as regular agents.
    &#34;&#34;&#34;
    return self.agents[agent_id] and (not self._timers[agent_id] or self._tick % 2 == 0) and not self.gameover</code></pre>
</details>
</dd>
<dt id="pacman.gamestate.Gamestate.destroy"><code class="name flex">
<span>def <span class="ident">destroy</span></span>(<span>self, agent_id)</span>
</code></dt>
<dd>
<section class="desc"><p>Destroy a certain agent. Contrary to <code>kill</code>, ghosts do not reset with <code>destroy</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def destroy(self, agent_id: int):
    &#34;&#34;&#34;
    Destroy a certain agent. Contrary to `kill`, ghosts do not reset with `destroy`.
    &#34;&#34;&#34;
    self.agents[agent_id] = None
    if agent_id == 0:  # Pacman forcefully destroyed as penalty (max ticks / timeout); subtract score
        self.score += self.SCORE_DIE_PENALTY</code></pre>
</details>
</dd>
<dt id="pacman.gamestate.Gamestate.kill"><code class="name flex">
<span>def <span class="ident">kill</span></span>(<span>self, agent_id)</span>
</code></dt>
<dd>
<section class="desc"><p>Kill a certain agent. In the case of ghosts, this resets them to their starting location.
The Gamestate calls this when there's an encounter between pacman and a ghost.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kill(self, agent_id: int):
    &#34;&#34;&#34;
    Kill a certain agent. In the case of ghosts, this resets them to their starting location.
    The Gamestate calls this when there&#39;s an encounter between pacman and a ghost.
    &#34;&#34;&#34;
    if agent_id == self.PACMAN_ID:
        self.agents[agent_id] = None
    else:
        self.agents[agent_id] = self.starts[agent_id]
        self._timers[agent_id] = 0</code></pre>
</details>
</dd>
<dt id="pacman.gamestate.Gamestate.legal_moves_id"><code class="name flex">
<span>def <span class="ident">legal_moves_id</span></span>(<span>self, agent_id)</span>
</code></dt>
<dd>
<section class="desc"><p>Get all moves from a particular agent's current location (taking walls into consideration).</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def legal_moves_id(self, agent_id: int):
    &#34;&#34;&#34;
    Get all moves from a particular agent&#39;s current location (taking walls into consideration).
    &#34;&#34;&#34;
    return self.legal_moves_vector(self.agents[agent_id])</code></pre>
</details>
</dd>
<dt id="pacman.gamestate.Gamestate.legal_moves_vector"><code class="name flex">
<span>def <span class="ident">legal_moves_vector</span></span>(<span>self, vector)</span>
</code></dt>
<dd>
<section class="desc"><p>Get all moves that are possible from a particular location (taking walls into consideration).</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def legal_moves_vector(self, vector: util.Vector):
    &#34;&#34;&#34;
    Get all moves that are possible from a particular location (taking walls into consideration).
    &#34;&#34;&#34;
    moves = set()
    for move in util.Move:
        new_vector = vector + move.vector
        if not self.walls[new_vector]:
            moves.add(move)
    return moves</code></pre>
</details>
</dd>
<dt id="pacman.gamestate.Gamestate.successor"><code class="name flex">
<span>def <span class="ident">successor</span></span>(<span>self, agent_id, move)</span>
</code></dt>
<dd>
<section class="desc"><p>Get a new gamestate based on this one, where the given agent has executed the given move.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def successor(self, agent_id: int, move: util.Move):
    &#34;&#34;&#34;
    Get a new gamestate based on this one, where the given agent has executed the given move.
    &#34;&#34;&#34;
    successor = self.copy
    successor.apply_move(agent_id, move)
    return successor</code></pre>
</details>
</dd>
<dt id="pacman.gamestate.Gamestate.successors"><code class="name flex">
<span>def <span class="ident">successors</span></span>(<span>self, agent_id)</span>
</code></dt>
<dd>
<section class="desc"><p>Get all possible gamestates following this one, in which the given agent had executed a single move.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def successors(self, agent_id: int):
    &#34;&#34;&#34;
    Get all possible gamestates following this one, in which the given agent had executed a single move.
    &#34;&#34;&#34;
    return [self.successor(agent_id, move) for move in self.legal_moves_vector(self.agents[agent_id])]</code></pre>
</details>
</dd>
<dt id="pacman.gamestate.Gamestate.tick"><code class="name flex">
<span>def <span class="ident">tick</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Increase the game's turn number.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tick(self):
    &#34;&#34;&#34;
    Increase the game&#39;s turn number.
    &#34;&#34;&#34;
    self._tick += 1

    if self._tick == self.MAX_TICKS:
        self.destroy(self.PACMAN_ID)
        print(f&#39;WARNING: max number of ticks reached ({self.MAX_TICKS}) pacman was destroyed&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pacman" href="index.html">pacman</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pacman.gamestate.Gamestate" href="#pacman.gamestate.Gamestate">Gamestate</a></code></h4>
<ul class="two-column">
<li><code><a title="pacman.gamestate.Gamestate.MAX_TICKS" href="#pacman.gamestate.Gamestate.MAX_TICKS">MAX_TICKS</a></code></li>
<li><code><a title="pacman.gamestate.Gamestate.PACMAN_ID" href="#pacman.gamestate.Gamestate.PACMAN_ID">PACMAN_ID</a></code></li>
<li><code><a title="pacman.gamestate.Gamestate.SCARED_TIME" href="#pacman.gamestate.Gamestate.SCARED_TIME">SCARED_TIME</a></code></li>
<li><code><a title="pacman.gamestate.Gamestate.SCORE_DIE_PENALTY" href="#pacman.gamestate.Gamestate.SCORE_DIE_PENALTY">SCORE_DIE_PENALTY</a></code></li>
<li><code><a title="pacman.gamestate.Gamestate.SCORE_GET_ALL_DOTS" href="#pacman.gamestate.Gamestate.SCORE_GET_ALL_DOTS">SCORE_GET_ALL_DOTS</a></code></li>
<li><code><a title="pacman.gamestate.Gamestate.SCORE_GET_DOT" href="#pacman.gamestate.Gamestate.SCORE_GET_DOT">SCORE_GET_DOT</a></code></li>
<li><code><a title="pacman.gamestate.Gamestate.SCORE_GET_GHOST" href="#pacman.gamestate.Gamestate.SCORE_GET_GHOST">SCORE_GET_GHOST</a></code></li>
<li><code><a title="pacman.gamestate.Gamestate.SCORE_GET_PELLET" href="#pacman.gamestate.Gamestate.SCORE_GET_PELLET">SCORE_GET_PELLET</a></code></li>
<li><code><a title="pacman.gamestate.Gamestate.SCORE_TICK_PENALTY" href="#pacman.gamestate.Gamestate.SCORE_TICK_PENALTY">SCORE_TICK_PENALTY</a></code></li>
<li><code><a title="pacman.gamestate.Gamestate.active_agents" href="#pacman.gamestate.Gamestate.active_agents">active_agents</a></code></li>
<li><code><a title="pacman.gamestate.Gamestate.apply_move" href="#pacman.gamestate.Gamestate.apply_move">apply_move</a></code></li>
<li><code><a title="pacman.gamestate.Gamestate.can_move" href="#pacman.gamestate.Gamestate.can_move">can_move</a></code></li>
<li><code><a title="pacman.gamestate.Gamestate.copy" href="#pacman.gamestate.Gamestate.copy">copy</a></code></li>
<li><code><a title="pacman.gamestate.Gamestate.destroy" href="#pacman.gamestate.Gamestate.destroy">destroy</a></code></li>
<li><code><a title="pacman.gamestate.Gamestate.dots" href="#pacman.gamestate.Gamestate.dots">dots</a></code></li>
<li><code><a title="pacman.gamestate.Gamestate.gameover" href="#pacman.gamestate.Gamestate.gameover">gameover</a></code></li>
<li><code><a title="pacman.gamestate.Gamestate.ghosts" href="#pacman.gamestate.Gamestate.ghosts">ghosts</a></code></li>
<li><code><a title="pacman.gamestate.Gamestate.kill" href="#pacman.gamestate.Gamestate.kill">kill</a></code></li>
<li><code><a title="pacman.gamestate.Gamestate.legal_moves_id" href="#pacman.gamestate.Gamestate.legal_moves_id">legal_moves_id</a></code></li>
<li><code><a title="pacman.gamestate.Gamestate.legal_moves_vector" href="#pacman.gamestate.Gamestate.legal_moves_vector">legal_moves_vector</a></code></li>
<li><code><a title="pacman.gamestate.Gamestate.loss" href="#pacman.gamestate.Gamestate.loss">loss</a></code></li>
<li><code><a title="pacman.gamestate.Gamestate.pacman" href="#pacman.gamestate.Gamestate.pacman">pacman</a></code></li>
<li><code><a title="pacman.gamestate.Gamestate.pellets" href="#pacman.gamestate.Gamestate.pellets">pellets</a></code></li>
<li><code><a title="pacman.gamestate.Gamestate.shape" href="#pacman.gamestate.Gamestate.shape">shape</a></code></li>
<li><code><a title="pacman.gamestate.Gamestate.successor" href="#pacman.gamestate.Gamestate.successor">successor</a></code></li>
<li><code><a title="pacman.gamestate.Gamestate.successors" href="#pacman.gamestate.Gamestate.successors">successors</a></code></li>
<li><code><a title="pacman.gamestate.Gamestate.tick" href="#pacman.gamestate.Gamestate.tick">tick</a></code></li>
<li><code><a title="pacman.gamestate.Gamestate.timers" href="#pacman.gamestate.Gamestate.timers">timers</a></code></li>
<li><code><a title="pacman.gamestate.Gamestate.walls" href="#pacman.gamestate.Gamestate.walls">walls</a></code></li>
<li><code><a title="pacman.gamestate.Gamestate.win" href="#pacman.gamestate.Gamestate.win">win</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>